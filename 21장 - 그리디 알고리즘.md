# 21장 - 그리디 알고리즘

>## 문제
>
>- 78 - 주식을 사고팔기 가장 좋은 시점 2
>- 79 - 키에 따른 대기열 재구성
>- 80 - 태스크 스케줄러
>- 81 - 주유소
>- 82 - 쿠키 부여

> 그리디 알고리즘은 글로벌 최적을 찾기 위해 각 단계에서 로컬 최적의 선택을 하는 휴리스틱 문제 해결 알고리즘이다

- 그리디 알고리즘은 바로 앞의 이익만을 좇는 알고리즘이다
- 그리디 알고리즘은 최적화 문제를 대상으로 한다
  - 잘 작동하는 문제는 `탐욕 선택 속성(Greedy Choice Property)`를 갖는 `최적 부분 구조(Optimal Substructure)`인 문제들이다
  - `탐욕 선택 속성` : **앞의 선택이 이후에 영향을 주지 않는 것**
  - 즉 그리디는 선택을 다시 고려하지 않는다
  - `최적 부분 구조` : 문제의 최적 해결 방법이, 부분 문제에 대한 최적 해결 방법으로 구성되는 경우를 뜻한다

- `탐욕 선택 속성`, `최적 부분 구조` 2가지를 만족하면 최적해를 찾을 수 있다
  - 혹은 정담을 근사하게 찾음

> 그리디 vs 다이나믹 프로그래밍
>
> - 다이나믹 프로그래밍은 하위 문제에 대한 최적의 솔루션을 찾고, 결과들을 결합한 정보에 입각해 전역 최적 솔루션에 대한 선택을 한다
> - 그리디는 각 단계마다 로컬최적해를 찾는 문제로 접근해 문제를 더 작게 줄여나가는 형태



- **우선순위 큐는 최소 혹은 최대값을 추출하기에 그리디에 어울리는 자료구조이다**

### 배낭 문제

> 배낭에 담을 수 있는 무게의 최대값(15kg)이 정해져있고
>
> 각각 짐의 가치와 무게가 있는 짐들을 배날에 넣을 때 가치의 합이 최대가 되도록하는 조합을 찾는 문제
> (4$, 12kg), (2$, 2kg), (2$, 1kg), (1$, 1kg), (10$, 4kg)

- 짐을 쪼갤 수 있는 경우인 `분할 가능 배낭 문제(Fractional Knapsack Problem)`
  - 그리디 알고리즘으로 해결
- 짐을 쪼갤 수 없는 `0-1 배낭 문제`
  - 다이나믹 프로그래밍으로 해결

#### 그리디로 문제 풀이

- 단가가 가장 높은 짐부터 차례대로 채워나가면 된다
  - 남은 공간은 쪼개서 담는다

```python
cargo = [(4,12), (2,1), (10,4), (1,1), (2,2)]

r = fractional_knapsack(cargo)
```

- 단가를 구해서 역순으로 정렬

  - 단가가 높은 짐이 맨 앞에 오도록 한다

  ```python
  def fractional_kanpsack(cargo):
      capacity = 15
      pack = []
      
      #단가 계산 역순 정렬
      for c in cargo:
          pack.append((c[0]/c[1], c[0], c[1]))	# 단가, 가치, 무게
      pack.sort(reverse=True)
      
      # 단가 순 그리디 계산
      total_value = 0
      for p in pack:
          if capacity - p[2] >= 0:
              capacity -= p[2]
              total_value += p[2]
          else:
              fraction = capacity / p[2]
              total_value += p[1] * fraction
              break
      
      return total_value
  ```

### 동전 바꾸기 문제

> 동전의 액면이 10원, 50원, 100원처럼 증가하면서 이전 액면의 배수 이상이 되면 그리디 알고리즘으로 풀 수 있다
>
> ex. 160원을 거슬러 준다면 100원 하나, 50원 하나, 10원 하나
>
> - 가장 적은 동전 개수로 거슬러줄 수 있다

- BUT 80원 짜리 동전이 있으면 그리디하게 풀 수 없다
  - 80원 2개가 정답인데 그리디는 100원부터 선택하게 된다
  - 다이나믹 프로그래밍으로 풀어야 된다

### 가장 큰 합(그리디 실패)

- 노드를 계속 더해가다가 마지막에 가장 큰 합이 되는 경로를 찾는 문제

> 7
> 3 	12
>
> 99,8	5, 6
>
> - 계속 큰 수만 더해나가면 7=>12=>6 이 된다
>   - 그리디로 풀 수 없다



## 배운점

- Counter 0이하인 아이템을 목록에서 제거

  ```python
  counter = collections.Counter(tasks)
  
  # 0이하 아이템을 목록에서 제거
  counter += collections.Counter()
  ```

  