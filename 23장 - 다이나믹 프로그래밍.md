# 23장 - 다이나믹 프로그래밍

> ## 문제
>
> - 85 - 피보나치 수
> - 86 - 최대 서브 배열
> - 87 - 계단 오르기
> - 88 - 집 도둑

- 다이나믹 프로그래밍 : 문제를 각각의 작은 문제로 나누어 해결한 결과를 저장해뒀다가 나중에 큰 문제의 결과와 합하여 풀이하는 알고리즘
  - 문제의 최적 해결 방법이 **부분 문제에 대한 최적 해결 방법으로 구성되는 문제**(**최적 부분 구조**)를 풀 수 있다
- 그리디는 항상 그 순간에 최적이라고 생각되는 것을 선택하는 반면
  - DP는 **중복된 하위 문제**의 결과를 저장해뒀다가 풀이해 나간다는 차이 존재
  - **중복되지 않으면 DP로 풀지 않는다**

| 알고리즘            | 풀이 가능한 문제들의 특징              | 풀이 가능한 문제 및 알고리즘                              |
| ------------------- | -------------------------------------- | --------------------------------------------------------- |
| 다이나믹 프로그래밍 | 최적 부분 구조<br />중복된 하위 문제들 | 0-1 배낭 문제<br />피보나치 수열<br />다익스트라 알고리즘 |
| 그리디 알고리즘     | 최적 부분 구조<br />탐욕 선택 속성     | 분할 가능 배낭 문제<br />다익스트라 알고리즘              |
| 분할 정복           | 최적 부분 구조                         | 병합정렬<br />퀵 정렬                                     |

- 다익스트라는 BFS시 항상 최단 경로 찾는 그리디이며, 계산한 경로를 저장해뒀다 사용하는 중복된 하위 문제들을 푸는 DP이기도 한다

## 최적 부분 구조

> 서울에서 부산까지 가는 최단 경로를 찾는 문제가 있다
>
> 서울에서 대구까지는 3경로, 대구에서 부산까지 3경로 존재
>
> - 서울에서 부산까지 가는 최단 경로는 각각의 부분 문제인
>
>   1. 서울에서 대구까지 가는 최단경로 문제
>   2. 대구에서 부산까지 가는 최단경로 문제
>
>   - 두 문제 해결 방법의 합이 답이다
>
> - 즉 **문제의 최적 해결 방법은 부분 문제에 대한 최적 해결 방법으로 구성된다**

### 중복된 하위 문제들

- 다이나믹 프로그래밍으로 풀 수 있는 문제들은 **중복된 하위 문제들을 갖는다는 점이** 다른 문제들과의 차이점이다

### 다이나믹 프로그래밍 방법론

- DP 방법론

  > 다이나믹 프로그래밍
  >
  > - 패러다임
  >   - 분할정복
  >     - 중복된 하위 문제들
  >     - 최적 부분 구조
  > - 방법론
  >   - **메모이제이션(하향식 접근법)**
  >   - **타뷸레이션(사향식 접근법)**

- 방법론은 상향식과 하향식으로 나뉜다
  - **상향식(타뷸레이션)** : 더 작은 하위 문제부터 살펴본 다음, **작은 문제의 정답을 이용해 큰 문제의 정답을 풀어나가는 방식**
    - 일반적으로 이 방식만은 DP라고 지칭하기도 한다
  - **하향식(메모이제이션)** : 하위 문제에 대한 정답을 계산했는지 확인해가면 문제를 자연스러운 방식으로 풀어가는 방식

### 상향식

```python
def fib(n):
    dp[0] = 0
    dp[1] = 1
    
    for i in range(2, n+1):
        dp[i] = d[i-1] + dp[i-2]
    return dp[n]
```

- 상향식 방법론은 **작은 하위 문제부터 차례대로 정답을 풀어나가며 큰 문제의 정답을 만든다**
- 데이터를 테이블 형태로 만들면서 문제를 풀이해 타뷸레이션 방식이라 한다



### 하향식

```python
def fib(n):
    if n<=1:
        return n
    
    if dp[n]:
        return dp[n]
    
    dp[n] = fib(n-1) + fib(n-2)
    return dp[n]
```

- 하위 문제에 대한 정답을 계산했는지 확인해가면 문제를 자연스럽게 재귀로 풀어나간다
  - 기존 재귀 풀이와 거의 동일하면서 **이미 풀어봤는지 확인하여 재활용**하는 효율적인 방식이다
  - **메모이제이션 방식**이라 한다



## 피보나치

- 타뷸레이션

  ```python
  # 타뷸레이션(상향식)
  class Solution:
      dp = collections.defaultdict(int)
  
      def fib(self, n: int) -> int:
          self.dp[1] = 1
  
          for i in range(2, n + 1):
              self.dp[i] = self.dp[i - 1] + self.dp[i - 2]
  
          return self.dp[n]
  ```

- 메모이제이션

  ```python
  # 메모이제이션(하향식)
  class Solution:
      dp = collections.defaultdict(int)
  
      def fib(self, n: int) -> int:
          if n <= 1:
              return n
  
          if self.dp[n]:
              return self.dp[n]
  
          self.dp[n] = self.fib(n - 1) + self.fib(n - 2)
  
          return self.dp[n]
  ```

  

## 0-1 배낭 문제

- 짐을 쪼갤 수 없다

```python
cargo = [(4,12), (2,1), (10,4), (1,1), (2,2)]

r = zero_one_knapsack(cargo)
```

- 6*16 행렬 현태의 중간 결과 테이블 생성

  - 타뷸레이션을 위함이다
  - (짐의 최대 개수 +1) * (배낭의 최대 용량 + 1)
  - 각 셀에는 그 위치까지의 짐의 개수와 배낭의 용량의 따른 최댓값 저장

- 풀이

  ```python
  def zero_one_knapsack(cargo):
      capacity = 15
      pack = []
      
      for i in range(len(cargo)+1):
          pack.append([])
          for c in range(capacity + 1):
              if i==0 or c==0:
                  pack[i].append(0)
              elif cargo[i-1][1] <= c:
                  pack[i].append(
                  max(cargo[i-1][0] + pack[i-1][c - cargo[i-1][1]], pack[i-1][c])
                  )
              else:
                  pack[i].append(pack[i-1][c]);
     
  	return pack[-1][-1]
               
  ```

  