# 19장 - 비트 조작

> ## 문제
>
> - 70 - 싱글 넘버
> - 71 - 해밍 거리
> - 72 - 두 정수의 합
> - 73 - UTF-8 검증
> - 74 - 1비트의 개수

## 부울 연산자

- 기본적인 부울 연산(Boolean Operation)

  - NOT, AND, OR: 기본 부울 연산자

  - XOR: 기본 부울 연산자 조합해 만든 보조 연산자

    ```python
    > x = y = True
    > (x and not y) or (not x and y)
    False
    # 다르면 True, 같으면 False
    ```

## 비트 연산자

- 비트 연산자(Bitwise Operator)

  ```python
  > True & False
  False
  
  > True | True
  True
  
  > True ^ True
  False
  
  > ~ True
  -2
  ```

  - **NOT은 2의 보수에서 1을 뺀 값**이기에 -2가 나왔다

    > 십진수로 표현하면
    > NOT x = -x - 1
    > NOT 1 = -1 - 1이 되어 -2 결과가 나옴

## 비트 조작 퀴즈

- 산술 연산(Arithmetic Operation)

  ```python
  > bin(0b0110 + 0b0010)	#덧셈
  '0b1000'
  
  > bin(0b0011 * 0b0101)	#곱셈
  '0b1111'
  
  > bin(0b1101 >> 2)		# 자릿수 만큼 오른쪽 시프팅(Shifting)
  '0b11'
  
  > bin(0b1101 << 2)		# 왼쪽 시프팅
  '0b110100'
  
  > bin(0b0101 ^ ~0b1100)	# 
  '-0b1010'
  ```

  - `1100 = 12`이므로 2의 보수 값은 `-13`이 된다
    - `-13 = 111111...110011`이므로 `0101`과 XOR 연산을 하면 `111111...110110`이 된다
    - 2의 보수로 표현하면 `-10`이므로 `-0b1010`이다

### 자릿수 제한 비트 연산

- `0b1100`를 `0b0011`로 바꾸는 방법

  - 자릿수 만큼의 최댓값을 지닌 비트 마스크 MASK 값과 XOR을 하면

    ```python
    > bin(0b1100 ^ 0b1111)
    '0b11'
    ```

  - 수정

    ```python
    > MASK = 0b1111
    > bin(0b0101 ^ (0b1100 ^ MASK))
    '0b110'
    # XOR 산술연산에서 원했던 값을 구했다 
    ```

> ### 파이썬의 진법 표현
>
> - 이진수(binary)
>
>   ```python
>   > bin(87)
>   '0b1010111'
>   
>   >int('0b1010111', 2)
>   87
>   >int('1010111', 2)	# 0b 생략도 가능
>   ```
>
>   - `bin()`은 이진수가 문자형으로 변환된다
>   - `int()`는 문자형인 이진수를 숫자 정수형으로 변환
>
>   ```python
>   > b = 0b1010111
>   > b
>   87
>   ```
>
>   - 이진수를 바로 대입하면 십진수 숫자형이 된다
>
> - 16진수
>
>   - `0x`로 시작한다
>
>   ```python
>   > hex(87)
>   '0x57'
>   
>   > c = 0x57
>   > c
>   87
>   ```



## 2의 보수

### 2의 보수 숫자 포맷

- 2의 보수는 컴퓨터가 음수를 저장하기 위해 일반적으로 취하는 방법 중 하나

- 4비트 레지스터 머신으로 가정하겠다

  - 4비트로 표현 가능 범위 : 0000 ~ 1111 (총 16개)
  - 음수를 표현하기 위해 **맨 앞 부호 비트(MSB, Most Significant Bit)**로 음수 표현한다
    - `1001 = -7`, `1000 = -8`, `1111 = -1`
  - 표현 범위 : -2^(n-1) ~ 2(n-1) - 1  [n은 비트개수]

- 4비트로 2의 보수를 표현하려면 비트 MASK를 사용한다

  ```python
  > MASK = 0xF
  > bin(1 & MASK)
  '0b1'
  > bin(7 & MASK)
  '0b111'
  > bin(-8 & MASK)
  '0b1000'
  > bin(-7 & MASK)
  '0b1001'
  ```

- 파이썬은 음수를 보여줄 때 부호만 덧붙여 보여준다

  ```python
  > bin(-5)
  '-0b101'
  ```

  - 즉 2의 보수 값을 실제로 보여주지 않는다

### 2의 보수 수학 연산

- 2의 보수 수학 연산은 가산 역 연산이다

  - 쉽게말해, 양수를 음수로, 음수를 양수로 바꾸는 작업이다

  - **NOT을 한 후 1을 더하면 된다**

    1. '비트 연산자 NOT'은 2의 보수에서 1을 뺀 것이다
    2. '2의 보수 수학 연산'은 비트 연산자 NOT에서 1을 더한 것

    > 0111의 2의 보수 연산은 1000+1 = 1001
    >
    > 1001의 비트 연산자 NOT(~1001)은 1001의 2보수인 0111에서 1을 뺀 0110이다

    > 0111인 7
    > 1001인 -7을 더하면
    > 10000으로 4비트 연산이니 초과한 자릿수 빼면 0000이다. 즉 0이다

### 비트 연산자 NOT

- NOT은 기준 비트 내에서 1을 0으로 0을 1로 바꿔준다

  > 4비트 가정
  >
  > ~0111 => 1000 즉 7이 -8이 된거다

- ```python
  > bin(0b0101 ^ ~0b1100)
  '-0b1010'
  ```

  - `0b1010`이 아닌 이유는 **4비트 포맷이 아니라서 그렇다**
  - 즉 `-4` 가 아닌 양수 `12`로 가정한것이다