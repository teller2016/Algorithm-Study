# 6장 - 문자열 조작

- `문자열 조작`: 문자열을 변경하거나 분리하는 등의 여러 과정

## 문제 풀이

- String Manipulation 폴더
  - 1 - 팰린드롬
  - 2- 문자열 뒤집기
  - 3 - 로그 파일 정렬
  - 4 - 가장 흔한 단어
  - 5 - 그룹 애너그램
  - 6 - 가장 긴 팰린드롬 부분 분자열

## 배운점

#### 문자, 문자열 조작

- 문자열 받아 영문자, 숫자 만 처리

  ```python
  char.isalnum();	# 영문자, 숫자 여부 판별 함수
  ```

- 영문자 소문자, 대문자 변환

  ```python
  s = s.lower()
  s = s.upper()
  ```

- 문자열 `join()`

  ```python
  s = ['a', 'b', 'c']
  ''.join(s)
  # abc 출력
  ```

#### 정규식

- 정규식으로 영문자, 숫자 뽑기

  ```python
  s = re.sub('[^a-z0-9]', '', s)
  ```

- 단어 뽑기

  - `\w`: 단어 문자(Word Character)

  - `^`: not

  - 두번째 인덱스로 치환

    ```python
    s = re.sub(r'[^\w]', ' ', s)
    # 단어 문자가 아닌 경우 ' '(공백)으로 치환해라
    ```

#### Counter 객체

- 선언 및 가장 흔하게 등장하는 단어 찾기

  ```python
  words = ['a', 'a', 'b', 'c', 'c', 'c']
  counts = collections.Counter(words)
  counts.most_common(2)
  #[('c', 3), ('a', 2)]
  ```

  - `most_common(n)`은 가장 많은 요소 n개 반환

#### 투 포인터

- 2개의 포인터를 이용해 범위를 조정해가며 풀이하는 방식

- ```python
  left, right = 0, len(str)
  while left < right:
      ...
      left += 1
      right -= 1
  ```



#### 람다 표현식

- 식별자 없이 실행 가능한 함수, 함수 선언 없이 하나의 식으로 함수를 단순하게 표현 가능

```python
s = ['2 3 A', '1 4 B', '4 6 C', '2 3 B']
```

- 번호 순으로 먼저 하고, 동일하면 문자 순으로 정렬

  ```python
  s.sort(key = lambda x: (x.split()[:2], x.split()[2]))
  # [:2]를 하여 여러 인덱스 동시에 비교 가능
  ```

- 직접 함수로 선언하는 경우

  ```python
  def func(x):
      return x.split()[:2], x.split()[2]
  s.sort(key=func)
  ```


#### max에서 key 사용

- `max()`에서 `key = len`사용하여 가장 길이가 큰 문자열 반환

  ```python
  > a = 'ab'
  > b = 'abc'
  > c = 'abcd'
  > max(a, b, c, key=len)
  'abcd'
  ```

  



### 여러가지 정렬 방법

- 파이썬은 `팀소트(Timsort)`라는 고성능 정렬 알고리즘을 사용

#### sorted() 함수

- 숫자, 문자 정렬 가능

  ```python
  >>> a = [2, 5, 1, 9]
  >>> sorted(a)
  [1, 2, 5, 9]
  
  >>> b = 'zbda'
  >>> sorted(b)
  ['a', 'b', 'd', 'z']
  ```

#### sort() 메서드

- 리스트 자체를 제자리 정렬한다

  - 반환값이 없다
  - 입력을 출력으로 덮어쓴다

  ```python
  >>> alist.sort()
  ```

#### key

- `key=` 옵션을 통해 키 또는 함수를 별도로 지정가능

  ```python
  >>> c = ['ccc', 'aaaa', 'd', 'bb']
  >>> sorted(c, key=len)	# 함수로 길이를 구하는 len사용
  ```

- 함수 이용

  ```python
  a = ['cde', 'cfc', 'abc']
  def fn(s):
      return s[0], s[-1]
  print(sorted(a, key=fn))
  # ['abc', 'cfc', 'cde']
  ```

  - s[0]을 먼저 비교하고 동일하면 s[-1]을 비교하여 정렬한다

  - 람다 표현식 사용

    ```python
    >>> sorted(a, key = lambda x: (x[0], x[-1]))
    ```

#### 정렬 알고리즘과 팀소트

- 가장 인기 있는 정렬 알고리즘 `병합 정렬(Merge Sort)`
  - 대부분 퀵 정렬이 빠르지만 데이터에 따라 편차가 크다
  - 병합 정렬은 일정하게 `O(n log n)`의 안정적인 성능을 보인다
- 파이썬은 `팀소트(Timsort)`를 사용한다
  - 실제 데이터는 대부분 이미 정렬되어 있을 것이라 가정하고 설계한 알고리즘
  - `삽입 정렬`, `병합 정렬`을 적절히 조합해 사용하는 정렬 알고리즘이다

| 알고리즘  | 시간복잡도 |         |         |
| --------- | ---------- | ------- | ------- |
|           | 최선       | 평균    | 최악    |
| 퀵 정렬   | n log n    | n log n | n^2     |
| 병합 정렬 | n log n    | n log n | n log n |
| 팀소트    | n          | n log n | n log n |

- **팀소트는 실제 데이터는 대부분 이미 정렬되어 있을 것이라 가정하여 이미 정렬되어 있는 경우 비교를 건너뛰어 최적화를 한다**



#### 유니코드와 UTF-8

- 초기에 문자 표현 방식 `ASCII 인코딩 방식`
  - 1바이트에 모든 문자를 표현
- 2~4 바이트의 공간에 문자 할당하는 방식 `유니코드(Unicode)`
  - 특수문자, 한글 등 다양한 문자 표현 가능해짐
  - **1바이트 문자도 2바이트의 메모리를 차지한다**
- **`UTF-8`: 가변 길이 문자 인코딩 방식으로 해결**
  - 유니코드 값에 따라 가변적으로 바이트를 결정하여 **불필요한 메모리 낭비를 절약한다**

- 파이썬은 사실 UTF-8 인코딩을 사용하지 않는다
  - 바이트 길이가 매번 달라져서 인덱스를 통해 개별 문자에 접근이 어렵다
    - 문자열 슬라이싱, 인덱스 접근 등이 어려워짐
  - 문자열 단위로 다른 고정길이 인코딩 방식 이용
    - ASCII 범위면 Latin-1(고정 1바이트 인코딩) 인코딩
    - 이외에는 UCS-2(고정 2바이트 인코딩)
    - 특수 기호, 희귀 언어 등은 UCS-4(고정 4바이트 인코딩)
  - **각 문자열에 포함된 문자 범위에 따라 서로 다른 고정 인코딩 방식을 택했다**